{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "breakpoint-display",
  "type": "registry:component",
  "title": "Breakpoint Display",
  "description": "A breakpoint display component.",
  "dependencies": ["class-variance-authority"],
  "files": [
    {
      "path": "registry/abui/utils/breakpoint-display.tsx",
      "content": "\"use client\"\n\nimport * as React from \"react\"\nimport { cva, type VariantProps } from \"class-variance-authority\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst breakpointDisplayVariants = cva(\n  \"pointer-events-none select-none bg-foreground text-background px-2 py-1 z-50 rounded-b\",\n  {\n    variants: {\n      position: {\n        fixed: \"fixed top-0 right-[50%] translate-x-1/2\",\n        relative: \"relative\",\n        absolute: \"absolute top-0 right-[50%] translate-x-1/2\",\n      },\n    },\n    defaultVariants: {\n      position: \"fixed\",\n    },\n  }\n)\n\n// Canonical ordering of breakpoints from smallest to largest\n// This defines the semantic order - actual pixel values are defined in Tailwind config\nconst BREAKPOINT_ORDER = [\"xxs\", \"xs\", \"sm\", \"md\", \"lg\", \"xl\", \"2xl\", \"3xl\"] as const\n\ntype BreakpointKey = (typeof BREAKPOINT_ORDER)[number]\n\n// Map breakpoint keys to their display labels\nconst BREAKPOINT_LABELS: Record<BreakpointKey, string> = {\n  xxs: \"XXS\",\n  xs: \"XS\",\n  sm: \"SM\",\n  md: \"MD\",\n  lg: \"LG\",\n  xl: \"XL\",\n  \"2xl\": \"2XL\",\n  \"3xl\": \"3XL\",\n}\n\n// Default Tailwind breakpoints (standard v3/v4)\nconst DEFAULT_BREAKPOINTS: BreakpointKey[] = [\"sm\", \"md\", \"lg\", \"xl\", \"2xl\"]\n\ninterface BreakpointDisplayProps\n  extends React.HTMLAttributes<HTMLDivElement>,\n    VariantProps<typeof breakpointDisplayVariants> {\n  /**\n   * Additional breakpoints to include beyond the default Tailwind breakpoints.\n   * These will be automatically sorted by semantic order (xxs < xs < sm < md < lg < xl < 2xl < 3xl).\n   * Actual pixel values are defined in your Tailwind configuration.\n   * @example extraBreakpoints={[\"xxs\", \"xs\", \"3xl\"]}\n   */\n  extraBreakpoints?: BreakpointKey[]\n}\n\nfunction BreakpointDisplay({ \n  className, \n  position, \n  extraBreakpoints = [],\n  ...props \n}: BreakpointDisplayProps) {\n  // Combine default and extra breakpoints, remove duplicates, and sort by semantic order\n  const allBreakpoints = React.useMemo(() => {\n    const combined = [...DEFAULT_BREAKPOINTS, ...extraBreakpoints]\n    const unique = Array.from(new Set(combined))\n    \n    // Sort by their position in the canonical BREAKPOINT_ORDER array\n    return unique.sort((a, b) => {\n      return BREAKPOINT_ORDER.indexOf(a) - BREAKPOINT_ORDER.indexOf(b)\n    })\n  }, [extraBreakpoints])\n\n  // Generate the display elements dynamically\n  const breakpointElements = React.useMemo(() => {\n    const elements: React.ReactNode[] = []\n    \n    // First element: show \"Minimum\" below the smallest breakpoint\n    const firstBreakpoint = allBreakpoints[0]\n    elements.push(\n      <p \n        key=\"minimum\" \n        className={cn(\"font-semibold block\", `${firstBreakpoint}:hidden`)}\n      >\n        Minimum\n      </p>\n    )\n    \n    // Middle elements: show each breakpoint between its range\n    for (let i = 0; i < allBreakpoints.length - 1; i++) {\n      const current = allBreakpoints[i]\n      const next = allBreakpoints[i + 1]\n      \n      elements.push(\n        <p\n          key={current}\n          className={cn(\n            \"font-semibold hidden\",\n            `${current}:block`,\n            `${next}:hidden`\n          )}\n        >\n          {BREAKPOINT_LABELS[current]}\n        </p>\n      )\n    }\n    \n    // Last element: show largest breakpoint from its min-width up\n    const lastBreakpoint = allBreakpoints[allBreakpoints.length - 1]\n    elements.push(\n      <p\n        key={lastBreakpoint}\n        className={cn(\"font-semibold hidden\", `${lastBreakpoint}:block`)}\n      >\n        {BREAKPOINT_LABELS[lastBreakpoint]}\n      </p>\n    )\n    \n    return elements\n  }, [allBreakpoints])\n\n  return (\n    <div\n      className={cn(breakpointDisplayVariants({ position }), className)}\n      {...props}\n    >\n      {breakpointElements}\n    </div>\n  )\n}\n\nexport { BreakpointDisplay, breakpointDisplayVariants }\nexport type { BreakpointDisplayProps, BreakpointKey }\n",
      "type": "registry:ui"
    }
  ]
}
